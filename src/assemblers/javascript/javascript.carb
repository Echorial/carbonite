class Carbonite.Assemblers.Javascript inherits Carbonite.Assemblers.Loose {
	bound public string indent(int n) {
		var str = "";
		while (str.length < n)
			str += "	";
		return str;
	}

	bound public override <string>function root(Carbonite.Class root) {
		if (this.compiler.doExport(root.route) == false)
			return "";
		
		if (root.doExport() == false)
			return "";
			
		if ((root.base == "relative") or (root.base == "interface")) {
			return "/" + "/Relative " + root.name + "\n";
		}else if (root.isFromHeader) {
			return "";
		}

		var <string>array props = new <string>array();
		var <string>array fixedProps = new <string>array();

		for (var int i in root.members) {
			var Carbonite.Member member = root.members[i];
			if (member.type == "property") {
				var Carbonite.Members.Property property = member;
				if ((property.binding != "fixed") and (property.abstract == false)) {
					props.push("	this." + property.name + " = " + this.expression(property.default, 0) + ";\n");
				}else{
					fixedProps.push(root.getRoute() + ".prototype." + property.name + " = " + this.expression(property.default, 0) + ";\n");
				}
			}
		}
		
		var <Carbonite.Members.Method>array cnsrs = root.getMethods("@construct");
		var string args = "";
		if (cnsrs.length > 0)
			if (cnsrs[0].hasFlag("trust")) {
				for (var int i in cnsrs[0].arguments) {
					var arg = cnsrs[0].arguments[i];
					args += arg.name;
					if (i != cnsrs[0].arguments.length - 1)
						args += ", ";
				}
			}

		var string str = root.getRoute() + " = function (" + args + ") {\n" + props.join("\n") + "\n" + this.overload(cnsrs) + "\n}\n" + fixedProps.join("\n") + "\n" + this.methods(root);
		return str;
	}

	bound public override <string>function overload(<Carbonite.Members.Method>array methods) {
		if (methods.length == 1) {
			var Carbonite.Members.Method method = methods[0];
			if (method.hasFlag("trust")) {
				return this.methodStr(method);
			}
		}

		var <string>array overloads = new <string>array();
		for (var int i in methods) {
			var Carbonite.Members.Method method = methods[i];
			if (method.abstract == false) {
				var <string>array check = new <string>array();
				var <string>array argInit = new <string>array();
				for (var int a in method.arguments) {
					var Carbonite.Argument argument = method.arguments[a];
					check.push(" && (" + this.compareType("arguments[" + a + "]", argument.type) + " || typeof arguments[" + a + "] == 'undefined' || arguments[" + a + "] === null)");
					var defName = argument.name;
					if (argument.name == "arguments") {
						defName = "___arguments";
					}
					argInit.push("		var " + defName  + " = arguments[" + a + "];\n");
				}
				
				overloads.push("	if (arguments.length == " + method.arguments.length() + check.join("") + ") {\n" + argInit.join("") + this.methodStr(method) + "\n	}\n");
			}
		}
		return overloads.join("else ");
	}

	bound public override <string>function methodStr(Carbonite.Members.Method method) {
		var string body = "";
		if (method.hasFlag("native")) {
			var <string>array argumentMaps = new <string>array();
			for (var int i = 0; i < method.arguments.length(); i++) {
				argumentMaps.push("arguments[" + i + "]");
			}
			var string context = "this";
			var <string>array templates = new <string>array();
			var Carbonite.Context ctx = new Carbonite.Context(context, argumentMaps, templates);
			body = method.generate(ctx);
		}else{
			body = this.body(method.body, 2);
		}
		return body;
	}

	bound public override <string>function methods(Carbonite.Class root) {
		var methods = new MethodMap();
		for (var int i in root.members) {
			var Carbonite.Member member = root.members[i];
			if (member.type != "property") {
				if (member.hasFlag("inline") == false) {
					if (member.name != "@construct") {
						if ((member.hasFlag("relative") == false) and (member.abstract == false)) {
							var Carbonite.Members.Method method = member;
							var overloads = methods.find(method.name);
							
							var <string>array check = new <string>array();
							var <string>array argInit = new <string>array();
							for (var int a in method.arguments) {
								var Carbonite.Argument argument = method.arguments[a];
								check.push(" && (" + this.compareType("arguments[" + a + "]", argument.type) + " || typeof arguments[" + a + "] == 'undefined' || arguments[" + a + "] === null)");
								var defName = argument.name;
								if (argument.name == "arguments") {
									defName = "___arguments";
								}
								argInit.push("		var " + defName + " = arguments[" + a + "];\n");
							}
							
							overloads.push("	if (arguments.length == " + method.arguments.length() + check.join("") + ") {\n" + argInit.join("") + this.methodStr(method) + "\n	}\n");
						}
					}
				}
			}
		}
		var string rtn = "";
		for (var int i in methods.methods) {
			var methodOverload = methods.methods[i];
			var <string>array overloads = methodOverload.overloads;
			var string gap = ".";
			var Carbonite.Members.Method method = root.getMember(methodOverload.name);
			if (method.binding != "fixed") {
				gap = ".prototype.";
			}
			if ((overloads.length == 1) and (method.hasFlag("trust"))) {
				var <string>array args = new <string>array();
				for (var int a in method.arguments) {
					var Carbonite.Argument argument = method.arguments[a];
					args.push(argument.name);
				}
				rtn += root.getRoute() + gap + method.getRealName() + " = function (" + args.join(", ") + ") {\n" + this.methodStr(method) + "}\n\n";
			}else{
				rtn += root.getRoute() + gap + method.getRealName() + " = function () {\n" + overloads.join("else ") + "}\n\n";
			}
		}
		return rtn;
	}

	bound public override <string>function compareType(string varName, Carbonite.Type to) {
		if (to.late) {
			return "typeof " + varName + " != 'undefined'";
		}
		return this.compareClass(varName, to.reference);
	}

	bound public override <string>function compareClass(string varName, Carbonite.Class to) {
		var string native = "";
		if ((to.route == "int") or (to.route == "uint64") or (to.route == "int64") or (to.route == "uint32") or (to.route == "int32") or (to.route == "uint16") or (to.route == "int16") or (to.route == "uint8") or (to.route == "int8")) {
			native = "number";
		}else if (to.route == "string") {
			native = "string";
		}else if (to.route == "function") {
			native = "function";
		}else if (to.route == "bool") {
			native = "boolean";
		}else if (to.route == "float") {
			native = "number";
		}else if (to.route == "array") {
			return varName + "instanceof Array";
		}else if (to.route == "map") {
			native = "object";
		}
		if (native.length == 0) {
			if (to.route == "everything") {
				return "(typeof " + varName + " == 'object')";
			}else{
				var <string>array tests = new <string>array();
				if (to.route != "primitive")
					tests.push(varName + " instanceof " + to.getRoute());
				for (var int i in to.descendants) {
					var Carbonite.Class child = to.descendants[i];
					tests.push(this.compareClass(varName, child));
				}
				return "(" + tests.join(" || ") + ")";
			}
		}else{
			return "typeof " + varName + " == '" + native + "'";
		}
	}

	bound public override <string>function body(Carbonite.Body body, int indent) {
		var <string>array statements = new <string>array();

		for (var int i in body.statements) {
			var Carbonite.Statement statement = body.statements[i];
			statements.push(this.indent(indent) + this.statement(statement, indent + 1));
		}

		return statements.join("\n");
	}

	bound public override <string>function define(Carbonite.Define define, int indent) {
		var string set = "";
		if (define.initializer != empty) {
			set = " = " + this.expression(define.initializer, indent);
		}
		var defName =  define.name;
		if (defName == "arguments") {
			defName = "___" + defName;
		}
		return "var " + defName + set;
	}

	bound public override <string>function statement(Carbonite.Statement statement, int indent) {
		if (statement.type == "define") {
			var Carbonite.Statements.Define def = statement;
			return this.define(def.define, indent) + ";";
		}else if (statement.type == "expression") {
			var Carbonite.Statements.Expression exp = statement;
			return this.expression(exp.expression, indent) + ";";
		}else if (statement.type == "throw") {
			var Carbonite.Statements.Throw exp = statement;
			return "throw " + this.expression(exp.expression, indent) + ";";
		}else if (statement.type == "return") {
			var Carbonite.Statements.Return exp = statement;
			return "return " + this.expression(exp.expression, indent) + ";";
		}else if (statement.type == "if") {
			var Carbonite.Statements.If ifState = statement;
			var string str = "";
			str = "if (" + this.expression(ifState.check, indent) + ") {\n" + this.body(ifState.body, indent) + "\n" + this.indent(indent) + "}";
			for (var int i in ifState.alternatives) {
				var Carbonite.Statements.IfAlternative alt = ifState.alternatives[i];
				if (alt.doCheck) {
					str += "else if (" + this.expression(alt.check, indent) + ") {\n" + this.body(alt.body, indent) + "\n" + this.indent(indent) + "}";
				}else{
					str += "else{\n" + this.body(alt.body, indent + 1) + "\n" + this.indent(indent) + "}";
				}
			}
			return str;
		}else if (statement.type == "for") {
			var Carbonite.Statements.For forState = statement;
			var string str = "";
			str = "for (" + this.define(forState.define, indent) + ";" + this.expression(forState.check, indent) + ";" + this.expression(forState.iterate, indent) + ") {\n" + this.body(forState.body, indent) + "\n" + this.indent(indent) + "}";
			return str;
		}else if (statement.type == "try") {
			var Carbonite.Statements.Try tryState = statement;
			var string str = "";
			var catches = new <string>array();
			for (var int i in tryState.catches) {
				var cat = tryState.catches[i];
				catches.push(this.indent(indent) + "if (" + this.compareType("_carb_catch_var", cat.overload) + " || typeof _carb_catch_var == 'undefined' || _carb_catch_var === null) {\n" + this.indent(indent + 1) + "var " + cat.name + " = _carb_catch_var;\n" + this.body(cat.body, indent) + "\n" + this.indent(indent) + "}");
			}
			str = "try {\n" + this.body(tryState.body, indent) + "\n" + this.indent(indent - 1) + "} catch (_carb_catch_var) {\n" + catches.join("else") + "\n" + this.indent(indent - 1) + "}";
			return str;
		}else if (statement.type == "forin") {
			var Carbonite.Statements.ForIn forState = statement;
			var string str = "";
			if (forState.iterate.output.reference.route == "array") {
				str = "for (" + this.define(forState.define, indent) + " = 0; " + forState.define.name + " < " + this.expression(forState.iterate, indent) + ".length; " + forState.define.name + "++) {\n" + this.body(forState.body, indent) + "\n" + this.indent(indent) + "}";
			}else{
				str = "for (" + this.define(forState.define, indent) + " in " + this.expression(forState.iterate, indent) + ") {\n" + this.body(forState.body, indent) + "\n" + this.indent(indent) + "}";
			}
			return str;
		}else if (statement.type == "while") {
			var Carbonite.Statements.While whileState = statement;
			return "while (" + this.expression(whileState.check, indent) + ") {\n" + this.body(whileState.body, indent) + "\n" + this.indent(indent) + "}";
		}else if (statement.type == "continue") {
			return "continue;";
		}else if (statement.type == "break") {
			return "break;";
		}else if (statement.type == "native") {
			var Carbonite.Statements.Native nativeState = statement;
			if (nativeState.platform == "javascript")
				return nativeState.content;
			return "";
		}
	}

	bound public override <string>function method(Carbonite.Members.Method method) {
		
	}

	bound public string escape(string content) {
		var newString = "";
		for (var int i = 0; i < content.length; i++) {
			var cur = content[i];
			if (cur == "\"" or cur == "\\") {
				newString += "\\" + cur;
			}else if (cur == "\n") {
				newString += "\\n";
			}else if (cur == "\r") {
				newString += "\\r";
			}else
				newString += cur;
		}
		return newString;
	}

	bound public override <string>function native(Carbonite.Native native) {
		if (native.type == "integer") {
			var Carbonite.Natives.Integer cast = native;
			var string rtn = cast.value;
			return rtn;
		}else if (native.type == "float") {
			var Carbonite.Natives.Float cast = native;
			var string rtn = cast.value;
			return rtn;
		}else if (native.type == "number") {
			var Carbonite.Natives.Integer cast = native;
			var string rtn = cast.value;
			return "" + rtn; //Hack until @cast
		}else if (native.type == "string") {
			var Carbonite.Natives.String cast = native;
			return '"' + this.escape(cast.value) + '"';
			return "\"" + cast.value.replace("\\", "\\\\").replace("\"", "\\\"").replace("\n", "\\n").replace("\r", "\\r") + "\""; //Warn
		}else if (native.type == "array") {
			var Carbonite.Natives.Array cast = native;
			var <string>array expressions = new <string>array();
			for (var int i in cast.value) {
				var Carbonite.Natives.ArrayItem item = cast.value[i];
				expressions.push(this.expression(item.value, 0));
			}
			return "[" + expressions.join(", ") + "]";
		}else if (native.type == "boolean") {
			var Carbonite.Natives.Boolean cast = native;
			if (cast.value) {
				return "true";
			}else{
				return "false";
			}
		}
	}

	bound public override <string>function property(Carbonite.Members.Property property) {
		
	}

	bound public override <string>function term(Carbonite.Term term, int indent) {
		if (term.type == "expression") {
			var Carbonite.Terms.Expression cast = term;
			var wrap = "(";
			var wEnd = ")";
			
			if (cast.expression.grouped == false) {
				wrap = "";
				wEnd = "";
			}

			return wrap + this.expression(cast.expression, indent) + wEnd;
		}else if (term.type == "literal") {
			var Carbonite.Terms.Literal cast = term;
			return this.native(cast.native);
		}else if (term.type == "function") {
			var Carbonite.Terms.Function cast = term;
			return this.func(cast.function, indent);
		}else if (term.type == "prefix") {
			var Carbonite.Terms.Prefix cast = term;
			var string doNew = "new ";
			var <Carbonite.Members.Method>array cstrs = cast.expression.output.reference.getMethods("@construct");
			var Carbonite.Members.Method cnstr = cstrs[0];
			if (cnstr.hasFlag("inline")) {
				doNew = "";
			}
			if (cast.prefix == "new") {
				return doNew + this.expression(cast.expression, indent);
			}
		}else if (term.type == "sequence") {
			var Carbonite.Terms.Sequence cast = term;
			return this.sequence(cast, indent);
		}
	}

	bound public override <string>function sequence(Carbonite.Terms.Sequence sequence, int indent) {
		var string rtn = "";

		for (var int i in sequence.parts) {
			var Carbonite.Part part = sequence.parts[i];
			if (part.type == "reference") {
				var Carbonite.Parts.Reference cast = part;
				if (cast.isConstant) {
					if (cast.isConstructor) {
						if (cast.constantReference.reference.name == "empty") {
							rtn += "null";
						}else{
							rtn += cast.constantReference.reference.getRoute();
						}
					}else{
						rtn += cast.constantReference.reference.getRoute();
					}
				}else{
					if (cast.reference.name == "arguments") {
						rtn += "___" + cast.reference.name;
					}else{
						rtn += cast.reference.name;
					}
				}
			}else if (part.type == "dot") {
				var Carbonite.Parts.Dot cast = part;
				if (cast.reference != empty) {
					if (cast.reference.type == "property") {
						var Carbonite.Members.ReferenceProperty refCast = cast.reference;
						if (refCast.reference.hasFlag("native")) {
							if (refCast.reference.hasFlag("inline") == false) {
								rtn += "." + refCast.reference.name;
							}
						}else{
							rtn += "." + refCast.reference.name;
						}
					}else{
						var Carbonite.Members.ReferenceMethod refMeth = cast.reference;
						if (refMeth.reference.hasFlag("native") == false) {
							rtn += "." + refMeth.reference.getRealName();
						}else if (refMeth.reference.hasFlag("property")) {
							var bool isNotCall = true;
							var string castI = i;
							var int ni = string.parseInt(castI) + 1;
							if (ni < sequence.parts.length()) {
								var Carbonite.Part next = sequence.parts[ni];
								if (next.type == "call") {
									isNotCall = false;
								}
							}
							if (isNotCall) {
								var <Carbonite.Expression>array strArr = new <Carbonite.Expression>array();
								rtn = this.callMethod(refMeth.reference, strArr, rtn, indent);
							}
						}
					}
				}else{
					rtn += "." + cast.output.reference.name;
				}
			}else if (part.type == "call") { //BUG: Reroutes don't work on calls
				var Carbonite.Parts.Call cast = part;
				if (cast.previous.type == "property") {
					
				}else if (cast.reference != null) {
					var bool normal = true;
					var Carbonite.Members.Method callOn = cast.reference.getReference();
					var string methodName = "";
					if (callOn.hasFlag("inline") == false) {
						methodName = "." + callOn.name;
					}
					if (callOn.hasFlag("native")) {
						rtn = this.callMethod(callOn, cast.arguments, rtn + methodName, indent);
					}else{
						rtn += this.callMethod(callOn, cast.arguments, "", indent);
					}
				}else{
					var <string>array args = new <string>array();
					for (var int a in cast.arguments) {
						args.push(this.expression(cast.arguments[a], 0));
					}
					rtn += "(" + args.join(", ") + ")";
				}
			}else if (part.type == "index") {
				var Carbonite.Parts.Index cast = part;
				var Carbonite.Members.Method callOn = cast.reference.getReference();
				var string methodName = "";
				if (callOn.hasFlag("inline") == false) {
					var <map>array attrs = callOn.getAttributes("name");
					var map mp = attrs[0];
					var string attr = mp["value"];
					methodName = "." + attr;
				}
				var <Carbonite.Expression>array castArr = new <Carbonite.Expression>array();
				castArr.push(cast.argument);
				if (callOn.hasFlag("native")) {
					rtn = this.callMethod(callOn, castArr, rtn + methodName, indent);
				}else{
					rtn += methodName + this.callMethod(callOn, castArr, "", indent);
				}
			}
		}

		return rtn;
	}

	bound public override <string>function callMethodWithStrings(Carbonite.Members.Method method, <string>array arguments, string context, int indent) {
		var bool normal = true;
		if (method.hasFlag("native")) {
			if (method.hasFlag("inline")) {
				normal = false;
			}
		}
		if (normal) {
			return context + "(" + arguments.join(", ") + ")";
		}else{
			var <string>array templates = new <string>array();
			var Carbonite.Context ctx = new Carbonite.Context(context, arguments, templates);
			return method.generate(ctx);
		}
	}

	bound public override <string>function callMethod(Carbonite.Members.Method method, <Carbonite.Expression>array arguments, string context, int indent) {
		var <string>array args = new <string>array();
		for (var int i in arguments) {
			var Carbonite.Expression arg = arguments[i];
			args.push(this.expression(arg, indent));
		}
		return this.callMethodWithStrings(method, args, context, indent);
	}

	string func(Carbonite.Function func, int indent) {
		var <string>array args = new <string>array();
		for (var int i in func.arguments) {
			var Carbonite.Argument arg = func.arguments[i];
			args.push(arg.name);
		}
		return "function (" + args.join(", ") + ") {\n" + this.body(func.body, indent) + "\n" + this.indent(indent) + "}";
	}

	bound public override <string>function expression(Carbonite.Expression expression, int indent) {
		var rtn = "";
		var string first = this.term(expression.first, indent);
		if (expression.reference != empty) {
			var <string>array args = new <string>array();
			if (expression.last != empty) {
				args.push(this.term(expression.last, indent));
			}
			if (expression.reference.hasFlag("native")) {
				return this.callMethodWithStrings(expression.reference, args, first, indent);
			}else{
				first += "." + expression.reference.getRealName() + this.callMethodWithStrings(expression.reference, args, "", indent);
			}
		}
		rtn = first;
		if (expression.grouped)
			return "(" + rtn + ")";
		else
			return rtn;
	}
}

class MethodOverload {
	string name = "";
	<string>array overloads = new <string>array();

	void @construct(string name) {
		this.name = name;
	}
}

class MethodMap {
	<MethodOverload>array methods = new <MethodOverload>array();

	void @construct() {
		
	}

	<string>array find(string name) {
		for (var int i in this.methods) {
			if (this.methods[i].name == name)
				return this.methods[i].overloads;
		}
		var method = new MethodOverload(name);
		this.methods.push(method);
		return method.overloads;
	}
}